var documenterSearchIndex = {"docs":
[{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"EditURL = \"../../../examples/walkthrough.jl\"","category":"page"},{"location":"generated/walkthrough/#Feature-walkthrough","page":"Feature Walkthrough","title":"Feature walkthrough","text":"","category":"section"},{"location":"generated/walkthrough/#Definition-of-Test-Powergrid","page":"Feature Walkthrough","title":"Definition of Test Powergrid","text":"","category":"section"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"In this example, we'll go through the main features of the NetworkDynamicsInspector package.","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"This package is all about inspecting the dynamic states of a network. To do so, we start by defining dynamic problem. The problem is stated in normal PowerDynamics.jl convention. This means, the edge states visible to the nodes are the complex currents (i_r, i_i) flowing into the node, the node states visible to the edges are the complex currents (u_r, u_i) established at the node.","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"using NetworkDynamics\nusing NetworkDynamicsInspector\nusing Graphs\nusing CairoMakie\nusing GraphMakie\nusing OrdinaryDiffEq\nusing DiffEqCallbacks\n\ng = SimpleGraph(5)\nadd_edge!(g, 1, 2); add_edge!(g, 1, 4); add_edge!(g, 2, 3); add_edge!(g, 2, 4);\nadd_edge!(g, 2, 5); add_edge!(g, 3, 5); add_edge!(g, 4, 5);\n\nntypes = [:gen, :load, :gen, :load, :load]\n\nnode_color = map(t->t==:gen ? Makie.wong_colors()[5] : Makie.wong_colors()[2], ntypes)\nfig, ax, p = graphplot(g; ilabels=repr.(1:5), node_color)\nhidedecorations!(ax); hidespines!(ax)\nfig #hide","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"Here, the blue nodes represent generators while the orange nodes represent loads.","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"Next we can define our node models. The swing node is typical represenation of the swing quation and has two parameters, mechanical turbine power P and damping D. It has three states, the internal angle δ and both components of the complex voltage.","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"function swing_vertex!(dv, v, edges, (P, M, D), t)\n    u_r, u_i, ω = v\n    i = total_current(edges)\n    u = u_r + u_i * im\n    δ = angle(u)\n\n    Pel = real(u*conj(i))\n    dω = M * (P + Pel - D*ω)\n\n    du_r = -sin(δ)*ω\n    du_i =  cos(δ)*ω\n\n    dv .= du_r, du_i, dω\n    nothing\nend\nswing = ODEVertex(; f=swing_vertex!, dim=3, mass_matrix=1.0, sym=[:u_r, :u_i, :ω], psym=[:P, :M, :D])\nnothing #hide","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"The load vertices is implemented as a constraint. It just forces u_r and u_i such that P=u⋅i*:","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"function pq_vertex!(dv, v, edges, (P,), t)\n    current = total_current(edges)\n    voltage = v[1] + v[2] * im\n    residual = P + voltage * conj(current)\n    dv[1] = real(residual)\n    dv[2] = imag(residual)\n    nothing\nend\nload = ODEVertex(; f=pq_vertex!, dim=2, mass_matrix=0.0, sym=[:u_r, :u_i], psym=[:P])\nnothing #hide","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"Both vertices need a helper function to find the total current inflow at the node:","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"function total_current(edges)\n    # ND convention: all flows entering a node are positive\n    current = 0.0im\n    @inbounds for e in edges\n        current += e[1] + e[2]*im\n    end\n    current\nend\nnothing #hide","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"For the edge model, we take the RMS represenation (static edge) of an edge with complex admittance (RL line), where the admittance Y is the onlye parameter.","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"function complex_admittance_edge!(e, v_s, v_d, (Y,), t)\n    src_voltage = v_s[1] + v_s[2] * im\n    dst_voltage = v_d[1] + v_d[2] * im\n    # If current is flowing away from the source, it is negative at the source.\n    complex_current = Y * (dst_voltage - src_voltage)\n    e[1] = real(complex_current)\n    e[2] = imag(complex_current)\n    nothing\nend\nedge = StaticEdge(; f=complex_admittance_edge!, dim=2, sym=[:i_r, :i_i], psym=[:Y], coupling=:antisymmetric)\nnothing #hide","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"Now we can finally create the nd object, the parameters and simulate:","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"vertex_list = map(t->t==:gen ? swing : load, ntypes)\nnd = network_dynamics(vertex_list, edge, g)\n\np_vert = [( 2.0, 10., 1.0), # inj and damping gen 1\n          (-0.5, NaN, NaN),  # draw load 2\n          ( 1.0, 10., 1.0), # inj and damping gen 3\n          (-0.5, NaN, NaN),  # draw load 2\n          (-2.0, NaN, NaN)]  # draw load 2\nnothing #hide\n# fillig up with `NaN` here helps us to achive concret parameter array eltype which is important for performance\n@assert isconcretetype(eltype(p_vert))\nnothing #hide\n\n# the edges are homogenious\np_edge = [5im for i in edges(g)]\nnothing #hide\n\n# network apraemters are the combination of vertex and edge parameters\n\np = (p_vert, p_edge)\npr = PRecord(p)\nnothing #hide","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"Not the usage of the PRecord struct: in order to reconstruct states later, it is sometimes necessary to know the parameters at that point in time. PRecord exists to \"preserve\" the parameters. Use record!(pr, integrator) within your callbacks where you change the parameters. Later on pr(t) can be used to restore the parameters for every timepoint of the solution object.","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"For the initial condition, we first initialize everything to 0 and than rais all the real parts of the voltage to 0","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"u0 = zeros(length(nd.syms))\nu0[idx_containing(nd, r\"^u_r\")] .= 1\n\ncbf = function(int)\n    int.p[2][4] = 0     # set conductivity of edge 1 to 0, basicially cutting the line\n    record!(pr, int)    # store the changed parameter in the `PRecord`\n    auto_dt_reset!(int) # reset the stepssize of the integrator\nend\ncallback = PresetTimeCallback(5, cbf)\n\nprob = ODEProblem(nd, u0, (0, 10), deepcopy(p); callback)\nsol = solve(prob, Rodas5P())\n@assert SciMLBase.successful_retcode(sol) \"Solver error: $(sol.retcode)\"\nnothing #hide","category":"page"},{"location":"generated/walkthrough/#Statelensens","page":"Feature Walkthrough","title":"Statelensens","text":"","category":"section"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"The main purpose of this package is to inspect variables. The entry point for that are the functions vstatef and estatef. Those function create a so called \"lens\" which helps us to retrieve a certain state","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"lens = vstatef(sol, pr, 1, :u_r) # creates lens to access state \"u_r\" of vertice 1\nlens(1.1) # evaluates lens at time 1.1 to get state at that point.","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"It is possible to create lenses wich access multiple variables or multiple indices at once:","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"estatef(sol, pr, 1, :src_i_r)(1.1)               # retrives state `:src_i_r` for edge 1 at time 1.1\nestatef(sol, pr, 1, [:src_i_r, :src_i_i])(1.1)   # retrives states `:src_i_r` and `:src_i_i` for edge 1 at time 1.1\nestatef(sol, pr, 1:2, [:src_i_r, :src_i_i])(1.1) # does the same for edges 1 and 2\nestatef(sol, pr, 2, [:src_i_r, :src_i_i])(sol.t) # gives both states for entiere time series at once\nnothing #hide","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"Those commands can be used to plot stuff relatively quickly, especially edge states which are much harde to aquire","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"ts = range(sol.t[begin], sol.t[end], length=1000) # more intermediate points to make graph smoother\nfig, ax, p = lines(ts, vstatef(sol,pr,1,:ω)(ts))\nlines!(ts, vstatef(sol,pr,3,:ω)(ts))\nfig #hide","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"On its own, that nice but it isn't really powerful. The interesting thing is now, that you can create your own \"recipes\" for intermediade states which are not really accessible. For example, lets consider you're interested in the voltage angle rather than the _r and _i components:","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"@register_vstatelens :u_arg => atan(:u_i, :u_r)\nlines(ts, vstatef(sol,pr,1,:u_arg)(ts))","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"you can delete the defined lens again","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"empty_lenses!()\nnothing #hide","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"lines(ts, vstatef(sol,pr,1,:u_arg)(ts)) would error now.","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"It is also possible to define more complex rules based on patternmatching","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"@register_vstatelens r\"^(.*)_mag$\" => sqrt(s\"\\1_r\"^2 + s\"\\1_i\"^2)\n@register_vstatelens r\"^(.*)_arg$\" => atan(s\"\\1_i\", s\"\\1_r\")\nnothing #hide","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"This registers a new NAME_mag and NAME_arg state, whenever there exists NAME_r and NAME_i","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"For more advance usage, you can define even more complex rules. Don't worry you don't need to fully understand the following code. What it does, it registers new virutal states _i_r and _i_i for each node, which are calculated based on the total current sum of the incomming edges.","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"Per convention, it uses the leading underscore to mark a \"virtual\" or \"derived\" state.","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"register_vstatelens!(r\"^_i_([ri])$\") do sol, idx, state\n    m = match(r\"_i_([ri])$\", string(state))\n    part = m[1] == \"i\" ? imag : real\n\n    let part=part\n        (gd, p, t) -> begin\n            i = total_current(get_dst_edges(gd, idx))\n            part(i)\n        end\n    end\nend\n@register_vstate :_i_r :_i_i\nnothing #hide","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"With that new definition in place, we can define even more virtual states:","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"@register_vstatelens :_S => (:u_r + :u_i*im)*(:_i_r - :_i_i*im)\n@register_vstatelens :_P => real(:_S)\n@register_vstatelens :_Q => imag(:_S)\nnothing #hide","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"Now we have easy acces to plot the measured power of our devices:","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"fig, ax, p = lines(ts, vstatef(sol,pr,1,:_P); label=\"Node 1\")\nlines!(ts, vstatef(sol,pr,2,:_P); label=\"Node 2\")\nlines!(ts, vstatef(sol,pr,3,:_P); label=\"Node 3\")\nlines!(ts, vstatef(sol,pr,4,:_P); label=\"Node 4\")\nlines!(ts, vstatef(sol,pr,5,:_P); label=\"Node 5\")\naxislegend()\nfig # hide","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"The good thing is, you don't need to define all those on you own. Just reuse existing lenses. Call","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"register_pd_lenses!()\nnothing #hide","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"To get a predfined lest of lenses which match the powerdynamics conventions. Most notably you get an additional vertex state :_ω for the estimated, instantanious frequency (based on the derivative of the voltage).","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"For the edges there is :_src_P and :dst_P to get the power at both ends. :_P gives you the maximum of those. Similarily there are Q and S for edges too.","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"We can use those to easily inspect the powerflow on the different edges in the network:","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"fig, ax, p = lines(ts, estatef(sol,pr,1,:_P)(ts); label=\"Edge 1\")\nlines!(ts, estatef(sol,pr,2,:_P)(ts); label=\"Edge 2\")\nlines!(ts, estatef(sol,pr,3,:_P)(ts); label=\"Edge 3\")\nlines!(ts, estatef(sol,pr,4,:_P)(ts); label=\"Edge 4\")\nlines!(ts, estatef(sol,pr,5,:_P)(ts); label=\"Edge 5\")\nlines!(ts, estatef(sol,pr,6,:_P)(ts); label=\"Edge 6\")\nlines!(ts, estatef(sol,pr,7,:_P)(ts); label=\"Edge 7\")\nfig #hide","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"A task which would be super annoying using the standard ND.jl methods.","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"For inspection, there are a few more interesting functions:","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"listvstates(sol, 1)   # shows you all states available for vertex 1\nlistvstates(sol, 1:2) # shows you all states available for vertex 1 AND 2 (intersection of both)\nlistvstates(sol)      # shows you all states available for ALL vertices in the network\nlistestates(sol, 1)   # same, but for edge states","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"if you want it more compact, there is","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"printvstates(sol, 1)","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"which is similar but supresses all the _r, _i, _arg, _mag endings.","category":"page"},{"location":"generated/walkthrough/#Interactive","page":"Feature Walkthrough","title":"Interactive","text":"","category":"section"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"To make use of the interactive features please download script and call","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"inspect_solution(sol,pr)","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"(Image: screenshot of interactive tool)","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"","category":"page"},{"location":"generated/walkthrough/","page":"Feature Walkthrough","title":"Feature Walkthrough","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = NetworkDynamicsInspector","category":"page"},{"location":"#NetworkDynamicsInspector","page":"Home","title":"NetworkDynamicsInspector","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for NetworkDynamicsInspector.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [NetworkDynamicsInspector]","category":"page"}]
}
